# Mesh-related functions
import pandas as pd
import numpy as np

# Reloading the module
import importlib

import Utility
importlib.reload(Utility)

import OrthogonalPolynomials
importlib.reload(OrthogonalPolynomials)

import Fourier
importlib.reload(Fourier)

def set_Mesh(name_solid):
    # Extract info from the mesh file in Abacus format (*.inp)
        # and write the info to csv files.
    # name_solid: string, name of the solid. 
        # This is both name of the folder and the mesh file name.
    
    #################################
    # Open files for writing data
    #################################

    # Node labels, coordinates
    f_nodes = open('./mesh/nodes.csv', 'w')
    # Element labels, element node labels
    f_elements = open('./mesh/elements.csv', 'w')
    
    # Boundary node labels, Dirichlet boundary
    f_tag_node_BC_Dirichlet = open('./mesh/tag_node_BC_Dirichlet.csv', 'w')
    # Boundary node labels, Neumann boundary
    f_tag_node_BC_Neumann = open('./mesh/tag_node_BC_Neumann.csv', 'w')
    
    # Boundary edge labels
    f_edge_BC = open('./mesh/tag_edge_BC.csv', 'w')
    # Boundary edge labels, Neumann boundary
    f_tag_edge_BC_Neumann = open('./mesh/tag_edge_BC_Neumann.csv', 'w')

    # Mesh file, Abaqus format, generated by gmsh
    path_mesh_file = f'./gmsh/{name_solid}/abaqus.inp'
    
    #################################
    # Read node coordinates
    #################################
    
    with open(path_mesh_file, 'r') as f_mesh:
        # Previous line
        line_old = ''
        for line in f_mesh:
            # Start reading node data below '*NODE\n'
            # If the previous line is '*NODE\n', start reading
            # Otherwise, move on to the next line
            if line_old != '*NODE\n': 
                line_old = line
            # Stop reading when line '******* E L E M E N T S *************\n' is reached
            elif line == '******* E L E M E N T S *************\n':
                break
            # Read node coordinates
            else:
                f_nodes.write(line)
                
    #################################
    # Read elements
    #################################        
    
    with open(path_mesh_file, 'r') as f_mesh:
        line_old = ''
        for line in f_mesh:
            # Start reading node data below ''*ELEMENT, type=CPS4, ELSET=Surface1\n'
            if line_old != '*ELEMENT, type=CPS4, ELSET=Surface1\n':
                line_old = line
            # Stop reading when line '*ELSET,ELSET=Dirichlet\n' is reached
            elif line == '*ELSET,ELSET=Dirichlet\n':
                break
            # Read elemental nodes's labels
            else:
                f_elements.write(line)
    
    #################################
    # Read Dirichlet BC nodes
    #################################  
    # Extract Dirichlet BC nodes:
    with open(path_mesh_file, 'r') as f_mesh:
        line_old = ''
        for line in f_mesh:
            # Start reading below '*NSET,NSET=Dirichlet\n'
            if line_old != '*NSET,NSET=Dirichlet\n':
                line_old = line
            # Stop reading when the first line beginning with * is reached
            elif line[0] == '*':
                break
            else: 
                # There may be several lines
                # To convert them into a single line,
                # we drop the last character '\n' by using [0:-1]
                f_tag_node_BC_Dirichlet.write(line[0:-1])
                
                
    #################################
    # Read Neumann BC nodes
    #################################  
    with open(path_mesh_file, 'r') as f_mesh:
        line_old = ''
        for line in f_mesh:
            # Start reading below '*NSET,NSET=Neumann\n'
            if line_old != '*NSET,NSET=Neumann\n':
                line_old = line
            # Stop reading when the first line beginning with * is reached
            elif line[0] == '*':
                break
            else: 
                # There may be several lines
                # To convert them into a single line,
                # we drop the last character '\n' by using [0:-1]
                f_tag_node_BC_Neumann.write(line[0:-1])

    #################################
    # Read boundary edges
    #################################  
    
    with open(path_mesh_file, 'r') as f_mesh:
        line_old = ''
        for line in f_mesh:
            # Start reading below '******* E L E M E N T S *************\n'
            if line_old != '******* E L E M E N T S *************\n':
                line_old = line
            # Stop reading when reaching '*ELEMENT, type=CPS4, ELSET=Surface1\n'
            elif line == '*ELEMENT, type=CPS4, ELSET=Surface1\n':
                break
            # The boundary edge info is stored in several blocks
            # Each block begins with a line whose first character is '*'.
            # Such a line should be skipped.
            elif line[0] != '*':  
                f_edge_BC.write(line)
    
    
    #################################
    # Read Neumann edges
    #################################
                
    with open(path_mesh_file, 'r') as f_mesh:
        line_old = ''
        for line in f_mesh:
            # Start reading below '*ELSET,ELSET=Neumann\n'
            if line_old != '*ELSET,ELSET=Neumann\n':
                line_old = line
            # Stop reading when the first line beginning with * is reached
            elif line[0] == '*':
                break
            else:  
                # There may be several lines
                # To convert them into a single line,
                # we drop the last character '\n' by using [0:-1]
                f_tag_edge_BC_Neumann.write(line[0:-1])
        

    #################################
    # Close file objects
    #################################
    f_nodes.close()
    f_elements.close()
    f_tag_node_BC_Dirichlet.close()
    f_tag_node_BC_Neumann.close()
    f_edge_BC.close()
    f_tag_edge_BC_Neumann.close()
    
    
    
    
def read_Nodes(name_solid, name_file):
    # Mesh file, Abaqus format, generated by gmsh
    path_mesh_file = f'./gmsh/{name_solid}/{name_file}'
    
    
    f_nodes = open('./mesh/nodes.csv', 'w')
    
    with open(path_mesh_file, 'r') as f_mesh:
        # Previous line
        line_old = ''
        for line in f_mesh:
            # Start reading node data below '*NODE\n'
            # If the previous line is '*NODE\n', start reading
            # Otherwise, move on to the next line
            if line_old != '*NODE\n': 
                line_old = line
            # Stop reading when line '******* E L E M E N T S *************\n' is reached
            elif line == '******* E L E M E N T S *************\n':
                break
            # Read node coordinates
            else:
                f_nodes.write(line)
                
                
    f_nodes.close()
    f_mesh.close()            
    
    ###########################
    # Read node info
    ###########################
    # Line format in 'nodes.csv': node label, x, y, z
    df = pd.read_csv('./mesh/nodes.csv', header=None)
    # Get the coordinates
    nodes = df.to_numpy()[:, 1:] 
    
    return nodes
    
    
    
    
    
def read_Elements_Tetrahedron(name_solid, name_file):
    # Mesh file, Abaqus format, generated by gmsh
    path_mesh_file = f'./gmsh/{name_solid}/{name_file}'
    
    
    # Element labels, element node labels
    f_elements = open('./mesh/elements.csv', 'w')
         
    
    with open(path_mesh_file, 'r') as f_mesh:
        line_old = ''
        for line in f_mesh:
            # Start reading node data below '******* E L E M E N T S *************\n'
            if line_old != '******* E L E M E N T S *************\n':
                line_old = line
            # Stop reading when line '*ELSET.....\n' is reached
            elif line[0:6] == '*ELSET':
                break
            # Read elemental nodes's labels
            elif line[0] != '*': 
                f_elements.write(line)
    
    f_elements.close()
    f_mesh.close()   
    
    
    # Line in 'elements.csv': element label, node 1 label, node 2 label, node 3 label 
    df = pd.read_csv('./mesh/elements.csv', header=None)
    # The first column include element labels. No need to store them
    elements = df.to_numpy()[:, 1:] 
    # The original node labels start from 1
    # Reduce the node labels by 1 according to python convention (starting from 0)
    elements -= 1
    
    return elements
    
    
  
    
    
def cal_Quantity_Tetrahedron(solid, name_solid, name_mesh_file, name_output_file):
    # Given a 3D mesh, compute the nodal values of displacement and stress
    # and write result into vtk file
    
    # Must run physical quantity computation codes first
    # to get e.U_polar, e.stress_polar, and e.stress_v_polar for each element e
    
    
    nodes = read_Nodes(name_solid, name_mesh_file)
    elements = read_Elements_Tetrahedron(name_solid, name_mesh_file)
    
    
    # Compute nodal values
    U = np.zeros((3, len(nodes)), dtype=complex) # Note that this is in Cartesian coordinates
    stress = np.zeros((3, 3, len(nodes)), dtype=complex)
    stress_v = np.zeros(len(nodes), dtype=complex)
    
    for idx_node, node in enumerate(nodes):
        # Convert coordinates
        x, y, z = node
        r = np.sqrt(x**2 + y**2)
        phi = np.angle(x + 1j * y)
        
        # Get the element containing the node and the corresponding xi and eta
        point = (r,z)
        e = Utility.get_Element(point, solid)
        xi, eta = e.cal_Coord_XiEta(point)
    
        N = e.grid.Nx
        M = e.grid.Ny
        
        # Interpolation
        for i in range(N+1):
            for j in range(M+1):
                li = OrthogonalPolynomials.LagrangePolynomialBary(i, xi, e.grid.nodes_x, e.grid.w_bary_x)     
                lj = OrthogonalPolynomials.LagrangePolynomialBary(j, eta, e.grid.nodes_y, e.grid.w_bary_y)
                
                u_polar = np.zeros(3, dtype=complex)
                for idx_u in range(3):
                    # Get the values at the same r and z
                    vals = e.U_polar[idx_u, :, i, j]
                    # Fourier interpolation
                    # Note that Uvals contains values at phi=0 and phi=2pi, which are the same. We drop the last one.
                    u_polar[idx_u] = Fourier.Interpolation(phi, vals[0:-1])
                    
                U[0, idx_node] += (u_polar[0] * np.cos(phi) - u_polar[1] * np.sin(phi)) * li * lj
                U[1, idx_node] += (u_polar[0] * np.sin(phi) + u_polar[1] * np.cos(phi)) * li * lj
                U[2, idx_node] += u_polar[2] * li * lj
                
                
                
                for a in range(3):
                    for b in range(3):
                        vals = e.stress_polar[a, b, :, i, j]
                        stress[a, b, idx_node] += Fourier.Interpolation(phi, vals[0:-1]) * li * lj
                        
                vals = e.stress_v_polar[:, i, j]
                stress_v[idx_node] += Fourier.Interpolation(phi, vals[0:-1]) * li * lj
                
    U = np.real(U) 
    stress = np.real(stress)
    stress_v = np.real(stress_v)      

    
                
                
    
    # Write result to vtk
    
    
    with open(f'./data/{name_output_file}', 'w') as f:
        # Write header
        f.write("# vtk DataFile Version 3.0\n")
        f.write("VTK file created with Python\n")
        f.write("ASCII\n")
        f.write("DATASET UNSTRUCTURED_GRID\n")
        
        # Write points
        f.write(f"POINTS {len(nodes)} float\n")
        for node in nodes:
            f.write(f"{node[0]} {node[1]} {node[2]}\n")
        
        # Write cells
        f.write(f"CELLS {len(elements)} {len(elements) * 5}\n")
        for e in elements:
            f.write(f"4 {e[0]} {e[1]} {e[2]} {e[3]}\n")
        
        # Write cell types
        f.write(f"CELL_TYPES {len(elements)}\n")
        for e in elements:
            f.write("10\n")
            
            
        f.write(f'POINT_DATA {len(nodes)}\n')   
            
        # Write displacement
        
        f.write("VECTORS u float\n")
        for idx_node in range(len(nodes)):
            f.write(f"{U[0, idx_node]} {U[1, idx_node]} {U[2, idx_node]}\n")
            
            
        # Write stress
        f.write("SCALARS stress_v float\n")
        f.write("LOOKUP_TABLE default\n")
        for value in stress_v:
            f.write(f"{value}\n")
        
        for a in range(3):
            for b in range(3):
                f.write(f'SCALARS stress{a}{b} float\n')
                f.write('LOOKUP_TABLE default\n')
                for value in stress[a,b]:
                    f.write(f"{value}\n")
                    
                    
    
                    

                    

##############################################
# Output
###############################################
def output_VTK(solid, name_folder):
    # Write data to VTK file
    f = open(f'./data/{name_folder}/data.vtk', 'w')
    f.write('# vtk DataFile Version 2.0\n')
    f.write('Mixed Scalar and Vector Data\n')
    f.write('ASCII\n')
    f.write('DATASET UNSTRUCTURED_GRID\n')
    
    # Compute the total number of points
    N = solid.element_list[0].grid.Nx # Grid size of a single dimension
    num_points = solid.num_elements * (N+1)**2 * (solid.Nphi+1)
    f.write(f'POINTS {num_points} float\n')

    # Write coordinates
    for phi in solid.phi:
        for e in solid.element_list:
            N = e.grid.Nx
            M = e.grid.Ny
            X = e.nodes_phy_x
            Y = e.nodes_phy_y
            for i in range(N+1):
                for j in range(M+1):
                    r = X[i,j]
                    z = Y[i,j]
                    x = r * np.cos(phi)
                    y = r * np.sin(phi)
                    f.write(f'{x} {y} {z}\n')
                    
    f.write(f'POINT_DATA {num_points}\n')    
    
    
          
                    
    # Write displacement
    f.write('VECTORS Displacement float\n')
    for idx_phi, phi in enumerate(solid.phi):
        for e in solid.element_list:
            N = e.grid.Nx
            M = e.grid.Ny
            X = e.nodes_phy_x
            Y = e.nodes_phy_y
            for i in range(N+1):
                for j in range(M+1):
                    u = np.real(e.U_polar[:, idx_phi, i, j])
                    ur = u[0]
                    uphi = u[1]
                    uz = u[2]
                    
                    ux = ur * np.cos(phi) - uphi * np.sin(phi)
                    uy = ur * np.sin(phi) + uphi * np.cos(phi)
                    f.write(f'{ux} {uy} {uz}\n')
    
    # Write stress
    for a in range(3):
        for b in range(3):
            f.write(f'SCALARS Stress{a}{b} float\n')
            f.write('LOOKUP_TABLE default\n')
            for idx_phi, phi in enumerate(solid.phi):
                for e in solid.element_list:
                    N = e.grid.Nx
                    M = e.grid.Ny
                    for i in range(N+1):
                        for j in range(M+1):
                            stress = np.real(e.stress_polar[a, b, idx_phi, i, j])
                            f.write(f'{stress}\n') 
                            
    
    f.write('SCALARS Stress_v float\n')
    f.write('LOOKUP_TABLE default\n')
    for idx_phi, phi in enumerate(solid.phi):
        for e in solid.element_list:
            N = e.grid.Nx
            M = e.grid.Ny
            for i in range(N+1):
                for j in range(M+1):
                    stress = np.real(e.stress_v_polar[idx_phi, i, j])
                    f.write(f'{stress}\n') 
    

    
    f.close()
        
    
    
    
    
    